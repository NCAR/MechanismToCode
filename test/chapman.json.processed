{
    "factor_solve_utilities_module": "module factor_solve_utilities\n\nuse ccpp_kinds, only: r8 => kind_phys \n\n! This code was generated by Preprocessor revision 2283875192b4b84b6c732ac0da99e12845b0f1da\n! Preprocessor source https://github.com/NCAR/MechanismToCode\n\n! This code is generated from tag 255 of the mechanism, Chapman.  It is named Chapman_vdemo\n! This tag was created on 2019-01-18 14:11:16.02075-07 by ajc and is marked as not buggy\n\n  implicit none\n\n  integer, parameter :: number_sparse_factor_elements = 16\n\n  public :: factor, solve \n\n  contains\n\n\nsubroutine backsolve_L_y_eq_b(LU,b,y)\n\n\n  real(r8), intent(in) :: LU(:)\n  real(r8), intent(in) :: b(:)\n  real(r8), intent(out) :: y(:)\n\n\n  y(1) = b(1)\n  y(2) = b(2)\n  y(2) = y(2) - LU(2) * y(1)\n  y(3) = b(3)\n  y(3) = y(3) - LU(3) * y(1)\n  y(3) = y(3) - LU(5) * y(2)\n  y(4) = b(4)\n  y(4) = y(4) - LU(7) * y(3)\n  y(5) = b(5)\n  y(5) = y(5) - LU(8) * y(3)\n  y(5) = y(5) - LU(12) * y(4)\n\n\nend subroutine backsolve_L_y_eq_b\n\n\n\nsubroutine backsolve_U_x_eq_y(LU,y,x)\n\n\n  real(r8), intent(in) :: LU(:)\n  real(r8), intent(in) :: y(:)\n  real(r8), intent(out) :: x(:)\n  real(r8) :: temporary\n\n\n  temporary = y(5)\n  x(5) = LU(16) * temporary\n  temporary = y(4)\n  temporary = temporary - LU(15) * x(5)\n  x(4) = LU(11) * temporary\n  temporary = y(3)\n  temporary = temporary - LU(10) * x(4)\n  temporary = temporary - LU(14) * x(5)\n  x(3) = LU(6) * temporary\n  temporary = y(2)\n  temporary = temporary - LU(9) * x(4)\n  temporary = temporary - LU(13) * x(5)\n  x(2) = LU(4) * temporary\n  temporary = y(1)\n  x(1) = LU(1) * temporary\n\n\nend subroutine backsolve_U_x_eq_y\n\nsubroutine factor(LU)\n\n\n  real(r8), intent(inout) :: LU(:)\n\n\n  LU(1) = 1./LU(1)\n  LU(2) = LU(2) * LU(1)\n  LU(3) = LU(3) * LU(1)\n  LU(4) = 1./LU(4)\n  LU(5) = LU(5) * LU(4)\n  LU(10) = LU(10) - LU(5)*LU(9)\n  LU(14) = LU(14) - LU(5)*LU(13)\n  LU(6) = 1./LU(6)\n  LU(7) = LU(7) * LU(6)\n  LU(8) = LU(8) * LU(6)\n  LU(11) = LU(11) - LU(7)*LU(10)\n  LU(12) = LU(12) - LU(8)*LU(10)\n  LU(15) = LU(15) - LU(7)*LU(14)\n  LU(16) = LU(16) - LU(8)*LU(14)\n  LU(11) = 1./LU(11)\n  LU(12) = LU(12) * LU(11)\n  LU(16) = LU(16) - LU(12)*LU(15)\n  LU(16) = 1./LU(16)\n\n\nend subroutine factor\n\nsubroutine solve(LU, x, b) \n\n  real(r8), intent(in) :: LU(:), b(:) ! solve LU * x = b \n  real(r8), intent(out) :: x(:) \n  real(r8) :: y(size(b)) \n\n  call backsolve_L_y_eq_b(LU, b, y)\n  call backsolve_U_x_eq_y(LU, y, x)\n\nend subroutine solve \n\n\nend module factor_solve_utilities\n",
    "kinetics_utilities_module": "module kinetics_utilities\nuse ccpp_kinds, only: r8 => kind_phys\n\n! This code was generated by Preprocessor revision 2283875192b4b84b6c732ac0da99e12845b0f1da\n! Preprocessor source https://github.com/NCAR/MechanismToCode\n\n! This code is generated from tag 255 of the mechanism, Chapman.  It is named Chapman_vdemo\n! This tag was created on 2019-01-18 14:11:16.02075-07 by ajc and is marked as not buggy\n\n  use factor_solve_utilities, only:  factor \n\n  implicit none\n\n  public :: dforce_dy_times_vector, factored_alpha_minus_jac, p_force, dforce_dy, kinetics_init, kinetics_final \n  contains\n\n\n\nsubroutine dforce_dy(LU, rate_constant, number_density, number_density_air)\n\n  ! Compute the derivative of the Forcing w.r.t. each chemical\n  ! Also known as the Jacobian\n  real(r8), intent(out) :: LU(:)\n  real(r8), intent(in) :: rate_constant(:)\n  real(r8), intent(in) :: number_density(:)\n  real(r8), intent(in) :: number_density_air\n\n  LU(:) = 0\n\n\n  ! df_O/d(N2)\n    !  k_N2_O1D_1: N2 + O1D -> 1*O + 1*N2\n    LU(3) = LU(3) + rate_constant(1) * number_density(2)\n\n\n  ! df_O1D/d(N2)\n    !  k_N2_O1D_1: N2 + O1D -> 1*O + 1*N2\n    LU(2) = LU(2) - rate_constant(1) * number_density(2)\n\n\n  ! df_O/d(O)\n    !  k_O_O3_1: O + O3 -> 2*O2\n    LU(6) = LU(6) - rate_constant(3) * number_density(5)\n\n    !  k_O_O2_M_1: M, O + O2 -> 1*O3\n    LU(6) = LU(6) - rate_constant(4) * number_density(4) * number_density_air\n\n\n  ! df_O2/d(O)\n    !  k_O_O3_1: O + O3 -> 2*O2\n    LU(7) = LU(7) + 2*rate_constant(3) * number_density(5)\n\n    !  k_O_O2_M_1: M, O + O2 -> 1*O3\n    LU(7) = LU(7) - rate_constant(4) * number_density(4) * number_density_air\n\n\n  ! df_O3/d(O)\n    !  k_O_O3_1: O + O3 -> 2*O2\n    LU(8) = LU(8) - rate_constant(3) * number_density(5)\n\n    !  k_O_O2_M_1: M, O + O2 -> 1*O3\n    LU(8) = LU(8) + rate_constant(4) * number_density(4) * number_density_air\n\n\n  ! df_O/d(O1D)\n    !  k_N2_O1D_1: N2 + O1D -> 1*O + 1*N2\n    LU(5) = LU(5) + rate_constant(1) * number_density(1)\n\n    !  k_O1D_O2_1: O1D + O2 -> 1*O + 1*O2\n    LU(5) = LU(5) + rate_constant(2) * number_density(4)\n\n\n  ! df_O1D/d(O1D)\n    !  k_N2_O1D_1: N2 + O1D -> 1*O + 1*N2\n    LU(4) = LU(4) - rate_constant(1) * number_density(1)\n\n    !  k_O1D_O2_1: O1D + O2 -> 1*O + 1*O2\n    LU(4) = LU(4) - rate_constant(2) * number_density(4)\n\n\n  ! df_O/d(O2)\n    !  k_O1D_O2_1: O1D + O2 -> 1*O + 1*O2\n    LU(10) = LU(10) + rate_constant(2) * number_density(2)\n\n    !  k_O_O2_M_1: M, O + O2 -> 1*O3\n    LU(10) = LU(10) - rate_constant(4) * number_density(3) * number_density_air\n\n    !  j_O2_1: O2 -> 2*O\n    LU(10) = LU(10) + 2*rate_constant(5)\n\n\n  ! df_O1D/d(O2)\n    !  k_O1D_O2_1: O1D + O2 -> 1*O + 1*O2\n    LU(9) = LU(9) - rate_constant(2) * number_density(2)\n\n\n  ! df_O2/d(O2)\n    !  k_O_O2_M_1: M, O + O2 -> 1*O3\n    LU(11) = LU(11) - rate_constant(4) * number_density(3) * number_density_air\n\n    !  j_O2_1: O2 -> 2*O\n    LU(11) = LU(11) - rate_constant(5)\n\n\n  ! df_O3/d(O2)\n    !  k_O_O2_M_1: M, O + O2 -> 1*O3\n    LU(12) = LU(12) + rate_constant(4) * number_density(3) * number_density_air\n\n\n  ! df_O/d(O3)\n    !  k_O_O3_1: O + O3 -> 2*O2\n    LU(14) = LU(14) - rate_constant(3) * number_density(3)\n\n    !  j_O3_2: O3 -> 1*O + 1*O2\n    LU(14) = LU(14) + rate_constant(7)\n\n\n  ! df_O1D/d(O3)\n    !  j_O3_1: O3 -> 1*O1D + 1*O2\n    LU(13) = LU(13) + rate_constant(6)\n\n\n  ! df_O2/d(O3)\n    !  k_O_O3_1: O + O3 -> 2*O2\n    LU(15) = LU(15) + 2*rate_constant(3) * number_density(3)\n\n    !  j_O3_1: O3 -> 1*O1D + 1*O2\n    LU(15) = LU(15) + rate_constant(6)\n\n    !  j_O3_2: O3 -> 1*O + 1*O2\n    LU(15) = LU(15) + rate_constant(7)\n\n\n  ! df_O3/d(O3)\n    !  k_O_O3_1: O + O3 -> 2*O2\n    LU(16) = LU(16) - rate_constant(3) * number_density(3)\n\n    !  j_O3_1: O3 -> 1*O1D + 1*O2\n    LU(16) = LU(16) - rate_constant(6)\n\n    !  j_O3_2: O3 -> 1*O + 1*O2\n    LU(16) = LU(16) - rate_constant(7)\n\nend subroutine dforce_dy\n\nsubroutine kinetics_init(vmr, number_density, number_density_air)\n\n real(r8), intent(in) :: vmr(:)\n real(r8), intent(out):: number_density(5)\n real(r8), intent(in) :: number_density_air\n\n\n number_density(1) = vmr(1) * number_density_air ! N2\n number_density(3) = vmr(2) * number_density_air ! O1D\n number_density(2) = vmr(3) * number_density_air ! O\n number_density(4) = vmr(4) * number_density_air ! O2\n number_density(5) = vmr(5) * number_density_air ! O3\n\nend subroutine kinetics_init\n\n\nsubroutine kinetics_final(vmr, number_density, number_density_air)\n\n real(r8), intent(out) :: vmr(:)\n real(r8), intent(in) :: number_density(5)\n real(r8), intent(in) :: number_density_air\n\n\n vmr(1) = number_density(1) / number_density_air ! N2\n vmr(2) = number_density(3) / number_density_air ! O1D\n vmr(3) = number_density(2) / number_density_air ! O\n vmr(4) = number_density(4) / number_density_air ! O2\n vmr(5) = number_density(5) / number_density_air ! O3\n\nend subroutine kinetics_final\n\n\nsubroutine factored_alpha_minus_jac(LU, alpha, dforce_dy)\n  !compute LU decomposition of [alpha * I - dforce_dy]\n\n  real(r8), intent(in) :: dforce_dy(:)\n  real(r8), intent(in) :: alpha\n  real(r8), intent(out) :: LU(:)\n\n  LU(:) = -dforce_dy(:)\n\n! add alpha to diagonal elements\n\n  LU(1) = -dforce_dy(1) + alpha \n  LU(4) = -dforce_dy(4) + alpha \n  LU(6) = -dforce_dy(6) + alpha \n  LU(11) = -dforce_dy(11) + alpha \n  LU(16) = -dforce_dy(16) + alpha \n\n  call factor(LU) \n\nend subroutine factored_alpha_minus_jac\n\nsubroutine p_force(rate_constant, number_density, number_density_air, force)\n  ! Compute force function for all molecules\n\n  real(r8), intent(in) :: rate_constant(:)\n  real(r8), intent(in) :: number_density(:)\n  real(r8), intent(in) :: number_density_air\n  real(r8), intent(out) :: force(:)\n\n\n\n! N2\n  force(1) = 0\n\n\n! O1D\n  force(2) = 0\n\n  ! k_N2_O1D_1: N2 + O1D -> 1*O + 1*N2\n  force(2) = force(2) - rate_constant(1) * number_density(1) * number_density(2)\n\n  ! k_O1D_O2_1: O1D + O2 -> 1*O + 1*O2\n  force(2) = force(2) - rate_constant(2) * number_density(2) * number_density(4)\n\n  ! j_O3_1: O3 -> 1*O1D + 1*O2\n  force(2) = force(2) + rate_constant(6) * number_density(5)\n\n\n! O\n  force(3) = 0\n\n  ! k_N2_O1D_1: N2 + O1D -> 1*O + 1*N2\n  force(3) = force(3) + rate_constant(1) * number_density(1) * number_density(2)\n\n  ! k_O1D_O2_1: O1D + O2 -> 1*O + 1*O2\n  force(3) = force(3) + rate_constant(2) * number_density(2) * number_density(4)\n\n  ! k_O_O3_1: O + O3 -> 2*O2\n  force(3) = force(3) - rate_constant(3) * number_density(3) * number_density(5)\n\n  ! k_O_O2_M_1: M, O + O2 -> 1*O3\n  force(3) = force(3) - rate_constant(4) * number_density(3) * number_density(4) * number_density_air\n\n  ! j_O2_1: O2 -> 2*O\n  force(3) = force(3) + 2*rate_constant(5) * number_density(4)\n\n  ! j_O3_2: O3 -> 1*O + 1*O2\n  force(3) = force(3) + rate_constant(7) * number_density(5)\n\n\n! O2\n  force(4) = 0\n\n  ! k_O_O3_1: O + O3 -> 2*O2\n  force(4) = force(4) + 2*rate_constant(3) * number_density(3) * number_density(5)\n\n  ! k_O_O2_M_1: M, O + O2 -> 1*O3\n  force(4) = force(4) - rate_constant(4) * number_density(3) * number_density(4) * number_density_air\n\n  ! j_O2_1: O2 -> 2*O\n  force(4) = force(4) - rate_constant(5) * number_density(4)\n\n  ! j_O3_1: O3 -> 1*O1D + 1*O2\n  force(4) = force(4) + rate_constant(6) * number_density(5)\n\n  ! j_O3_2: O3 -> 1*O + 1*O2\n  force(4) = force(4) + rate_constant(7) * number_density(5)\n\n\n! O3\n  force(5) = 0\n\n  ! k_O_O3_1: O + O3 -> 2*O2\n  force(5) = force(5) - rate_constant(3) * number_density(3) * number_density(5)\n\n  ! k_O_O2_M_1: M, O + O2 -> 1*O3\n  force(5) = force(5) + rate_constant(4) * number_density(3) * number_density(4) * number_density_air\n\n  ! j_O3_1: O3 -> 1*O1D + 1*O2\n  force(5) = force(5) - rate_constant(6) * number_density(5)\n\n  ! j_O3_2: O3 -> 1*O + 1*O2\n  force(5) = force(5) - rate_constant(7) * number_density(5)\n\nend subroutine p_force\n\npure subroutine dforce_dy_times_vector(dforce_dy, vector, cummulative_product)\n\n  !  Compute product of [ dforce_dy * vector ]\n  !  Commonly used to compute time-truncation errors [dforce_dy * force ]\n\n  real(r8), intent(in) :: dforce_dy(:) ! Jacobian of forcing\n  real(r8), intent(in) :: vector(:)    ! Vector ordered as the order of number density in dy\n  real(r8), intent(out) :: cummulative_product(:)  ! Product of jacobian with vector\n\n  cummulative_product(:) = 0\n\n\n  ! df_O/d(N2) * N2_temporary\n  cummulative_product(3) = cummulative_product(3) + dforce_dy(3) * vector(1)\n\n\n  ! df_O1D/d(N2) * N2_temporary\n  cummulative_product(2) = cummulative_product(2) + dforce_dy(2) * vector(1)\n\n\n  ! df_O/d(O) * O_temporary\n  cummulative_product(3) = cummulative_product(3) + dforce_dy(6) * vector(3)\n\n\n  ! df_O2/d(O) * O_temporary\n  cummulative_product(4) = cummulative_product(4) + dforce_dy(7) * vector(3)\n\n\n  ! df_O3/d(O) * O_temporary\n  cummulative_product(5) = cummulative_product(5) + dforce_dy(8) * vector(3)\n\n\n  ! df_O/d(O1D) * O1D_temporary\n  cummulative_product(3) = cummulative_product(3) + dforce_dy(5) * vector(2)\n\n\n  ! df_O1D/d(O1D) * O1D_temporary\n  cummulative_product(2) = cummulative_product(2) + dforce_dy(4) * vector(2)\n\n\n  ! df_O/d(O2) * O2_temporary\n  cummulative_product(3) = cummulative_product(3) + dforce_dy(10) * vector(4)\n\n\n  ! df_O1D/d(O2) * O2_temporary\n  cummulative_product(2) = cummulative_product(2) + dforce_dy(9) * vector(4)\n\n\n  ! df_O2/d(O2) * O2_temporary\n  cummulative_product(4) = cummulative_product(4) + dforce_dy(11) * vector(4)\n\n\n  ! df_O3/d(O2) * O2_temporary\n  cummulative_product(5) = cummulative_product(5) + dforce_dy(12) * vector(4)\n\n\n  ! df_O/d(O3) * O3_temporary\n  cummulative_product(3) = cummulative_product(3) + dforce_dy(14) * vector(5)\n\n\n  ! df_O1D/d(O3) * O3_temporary\n  cummulative_product(2) = cummulative_product(2) + dforce_dy(13) * vector(5)\n\n\n  ! df_O2/d(O3) * O3_temporary\n  cummulative_product(4) = cummulative_product(4) + dforce_dy(15) * vector(5)\n\n\n  ! df_O3/d(O3) * O3_temporary\n  cummulative_product(5) = cummulative_product(5) + dforce_dy(16) * vector(5)\n\n\nend subroutine dforce_dy_times_vector\n\nend module kinetics_utilities\n",
    "rate_constants_utility_module": "module rate_constants_utility \n\nuse ccpp_kinds, only: r8 => kind_phys \n\n! This code was generated by Preprocessor revision 2283875192b4b84b6c732ac0da99e12845b0f1da\n! Preprocessor source https://github.com/NCAR/MechanismToCode\n\n! This code is generated from tag 255 of the mechanism, Chapman.  It is named Chapman_vdemo\n! This tag was created on 2019-01-18 14:11:16.02075-07 by ajc and is marked as not buggy\n\n  implicit none\n\n  public :: p_rate_mapping,  k_rate_constant \n\n  contains\n\nsubroutine p_rate_mapping(tuv_rates, j_rate_const)\n    real(KIND=r8),           intent(in)  :: tuv_rates(:) ! /sec \n    real(KIND=r8),           intent(out) :: j_rate_const(:) ! /sec \n    j_rate_const(1) = tuv_rates(1) \n    j_rate_const(2) = tuv_rates(2) \n    j_rate_const(3) = tuv_rates(3) \nend subroutine p_rate_mapping \n\nsubroutine k_rate_constant(k_rate_constants, TEMP)\n    real(KIND=r8),           intent(in)  :: TEMP ! temperature\n    real(KIND=r8),           intent(out) :: k_rate_constants(:) ! rate constant for the each reaction\n    k_rate_constants(1) =  2.150000e-11_r8 * exp(110.00_r8 / TEMP)  \n    k_rate_constants(2) =  3.300000e-11_r8 * exp(55.00_r8 / TEMP)  \n    k_rate_constants(3) =  8.000000e-12_r8 * exp(-2060.00_r8 / TEMP)  \n    k_rate_constants(4) = usr_O_O2( temp ) \nend subroutine k_rate_constant \n\n\n\nREAL(KIND=r8) FUNCTION usr_O_O2( temp )\n! for cesm-consistent reaction labels\n! O+O2+M -> O3+M\n\n    REAL(KIND=r8), INTENT(IN) :: temp\n\n    usr_O_O2 = 6.00e-34_r8*(temp/300._r8)**(-2.4_r8)\n\nEND FUNCTION usr_O_O2\n\n\nend module rate_constants_utility\n"
}
